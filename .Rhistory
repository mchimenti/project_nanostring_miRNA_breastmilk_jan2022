# }
#
# #### INPUT: rcc - input from rcc (use readRcc from NanoStringQCPro)
# ####         low, high - the lower and upper limits for binding density
# #### OUTPUT: flag for binding density
#
# bindingDensityQC <- function(rcc,low,high){
#
#     bd = as.numeric(rcc$Lane_Attributes[6])
#     if(!(bd < high & bd > low)) {return('Flag')}
#     if (bd < high & bd > low) {return('No flag')}
#
#
# }
#
# #### INPUT: rcc - input from rcc (use readRcc from NanoStringQCPro)
# #### OUTPUT: flag for linearity for positive controls
#
# positiveLinQC <- function(rcc){
#
#     counts = rcc$Code_Summary
#     posControls = as.numeric(counts$Count[grepl('POS_',counts$Name)])
#     known = c(128,128/4,128/16,128/64,128/256,128/(256*4))
#     r2 = summary(lm(sort(posControls)~sort(known)))$r.squared
#     if(!(r2 > .95) | is.na(r2)) {return('Flag')}
#     if(r2 > .95) {return('No flag')}
#
# }
#
# #### INPUT: rcc - input from rcc (use readRcc from NanoStringQCPro)
# ####         numSD - number of standard deviations to calibrate the LOD
# #### OUTPUT: flag for limit of detection
#
# limitOfDetectionQC <- function(rcc,numSD = 0){
#
#     counts = rcc$Code_Summary
#     posE = as.numeric(counts$Count[counts$Name == 'POS_E'])
#     negControls = as.numeric(counts$Count[grepl('NEG',counts$Name)])
#     if(!(posE > mean(negControls) + numSD*sd(negControls))) {return('Flag')}
#     if (posE > mean(negControls) + numSD*sd(negControls)) {return('No flag')}
#
# }
##### HERE IS THE RUV CALCULATION AS IMPLEMENTED IN NANONORMITER()
# RUV_total <- function(raw,pData,fData,k,hkgenes = NULL,exclude = NULL){
#
#     library(RUVSeq)
#     library(DESeq2)
#     library(limma)
#     library(matrixStats)
#
#     if (!is.null(hkgenes)){
#
#         fData(set)$Class[rownames(set) %in% hkgenes] = 'Housekeeping'
#
#     }
#
#     fData = fData[rownames(raw),]
#     int = intersect(rownames(raw),rownames(fData))
#     fData = fData[int,]
#     raw = raw[int,]
#
#     set <- newSeqExpressionSet(as.matrix(round(raw)),
#                                phenoData=pData,
#                                featureData=fData)
#
#     cIdx <- rownames(set)[fData(set)$Class == "Housekeeping"]
#     cIdx = cIdx[!(cIdx %in% exclude)]
#     x <- as.factor(pData$Group)
#     set <- betweenLaneNormalization(set, which="upper")
#     set <- RUVg(set, cIdx, k=k)
#     dds <- DESeqDataSetFromMatrix(counts(set),colData=pData(set),design=~1)
#     rowData(dds) <- fData
#     dds <- estimateSizeFactors(dds)
#     dds <- estimateDispersionsGeneEst(dds)
#     cts <- counts(dds, normalized=TRUE)
#     disp <- pmax((rowVars(cts) - rowMeans(cts)),0)/rowMeans(cts)^2
#     mcols(dds)$dispGeneEst <- disp
#     dds <- estimateDispersionsFit(dds, fitType="mean")
#     vsd <- varianceStabilizingTransformation(dds, blind=FALSE)
#     mat <- assay(vsd)
#     covars <- as.matrix(colData(dds)[,grep("W",colnames(colData(dds))),drop=FALSE])
#     mat <- removeBatchEffect(mat, covariates=covars)
#     assay(vsd) <- mat
#     return(list(set = set,vsd = vsd))
#
# }
meta_df_full <- readxl::read_xlsx('cleaned_metadata.xlsx', sheet = 'Sheet1', col_names = TRUE, col_types = "guess")
meta_df <- meta_df_full %>% dplyr::select(c(`file name`, batch, `study ID`, Age, Race, `prepregnancy BMI`, `current  BMI`, `Breast milk colllection date post delivary`, `Delivery type`))
colnames(meta_df) <- c("filename","batch","SampleID","age","race","prepreg_BMI","curr_BMI","milk_col_dt", "delivery")
meta_df$batch[28:40] <- "4"  #fix the singleton batch
## Overweight >= 25.  Obese >=30.
meta_df <- meta_df %>%  dplyr::mutate(
status_ob = dplyr::case_when(
.data$prepreg_BMI < 25 ~ "Lean",
.data$prepreg_BMI >= 30 ~ "Obese",
(.data$prepreg_BMI >= 25 & .data$prepreg_BMI < 30) ~ "Overweight"
)
)
#getwd()
files.RCC = list.files(".", full.names = TRUE)
files.RCC = files.RCC[grepl('RCC',files.RCC)]
head(files.RCC)
ng = nrow(readRcc(files.RCC[1])$Code_Summary)
ncol = length(files.RCC)
raw_expression = as.data.frame(matrix(nrow = ng,ncol = length(files.RCC)+2))
colnames(raw_expression)[1:2] = c('Gene','Class')
pData = as.data.frame(matrix(nrow = length(files.RCC),ncol = 11))
colnames(pData) = c('BCAC_ID','SampleID','Owner','Comments','Date','GeneRLF','SystemAPF','imagingQC',
'bindingDensityQC','limitOfDetectionQC','positiveLinearityQC')
raw_expression[,1:2] = readRcc(files.RCC[1])$Code_Summary[,c(2,1)]
head(pData, 5)
head(raw_expression, 5)
## NOTE: I have to override the positiveLinQC function for this panel b/c it uses two types of positive controls and that confuses the grepl search.
positiveLinQC <- function(rcc){
counts = rcc$Code_Summary
#posControls = as.numeric(counts$Count[grepl('POS_',counts$Name)])
posControls = as.numeric(counts$Count[grepl('^POS_',counts$Name)])
known = c(128,128/4,128/16,128/64,128/256,128/(256*4))
r2 = summary(lm(sort(posControls)~sort(known)))$r.squared
if(!(r2 > .95) | is.na(r2)) {return('Flag')}
if(r2 > .95) {return('No flag')}
}
## Override this function to account for two types of Neg controls.
limitOfDetectionQC <- function(rcc,numSD = 0){
counts = rcc$Code_Summary
posE = as.numeric(counts$Count[counts$Name == 'POS_E'])
negControls = as.numeric(counts$Count[grepl('^NEG',counts$Name)])
if(!(posE > mean(negControls) + numSD*sd(negControls))) {return('Flag')}
if (posE > mean(negControls) + numSD*sd(negControls)) {return('No flag')}
}
##
## Populate pData and raw expr tables from RCC files
for (i in 1:length(files.RCC)){
#i = 1
print(i)
rcc = readRcc(files.RCC[i])
raw = rcc$Code_Summary
raw_expression[,i+2] = as.numeric(raw$Count)
#colnames(raw_expression)[i+2] = strsplit(files.RCC[i],'_')[[1]][2:4]
pData[i,2:7] = as.vector(rcc$Sample_Attributes)
pData$imagingQC[i] = imagingQC(rcc)
pData$bindingDensityQC[i] = bindingDensityQC(rcc,.05,2.25)
pData$limitOfDetectionQC[i] = limitOfDetectionQC(rcc)
pData$positiveLinearityQC[i] = positiveLinQC(rcc)
}
## Munge pData and metadata together; create treatment classes
pData$SampleID <- meta_df$SampleID
pData <- dplyr::left_join(pData, meta_df, by = "SampleID")
rownames(pData) <- pData$SampleID
colnames(raw_expression)[3:82] <- pData$SampleID
head(pData)
pData
raw = raw_expression[,-c(1:2)]
fData = raw_expression[,c(1:2)]
rownames(raw) = fData$Gene
cIdx <- fData$Gene[fData$Class == "Housekeeping"]
pData$HK_Gene_Miss = colSums(raw[cIdx,] == 0)
rownames(fData) = fData$Gene
rownames(raw) = fData$Gene
#rownames(pData) = colnames(raw)
#
norm.dat.k2 <- NanoNormIter::RUV_total(raw,pData,fData,k = 2)
dat <- norm.dat.k2$set
dat <- dat[,dat$batch %in% c("1","2","3","5","6","7","8","9")]  ## Drop outlier batch 4
dat_ob <- dat[,dat$status_ob %in% c("Lean","Obese")]  ## drop overweight samples, keep obese + lean
pData_2 <- pData(dat_ob)
pData_2 <- pData_2 %>% as_tibble() %>% mutate(milk_col_factor = as.factor(ntile(milk_col_dt, 4))) #Quartile bins of collection date
dds_ob <- DESeqDataSetFromMatrix(countData = counts(dat_ob[26:823,]),
colData = pData_2,
design = ~ W_1 + W_2 + milk_col_factor + status_ob)
dds_ob <- DESeq(dds_ob)
res_OB_MCF <- as.data.frame(results(dds_ob,contrast = c('status_ob','Obese','Lean')))
## Table of top DE genes
res_OB_MCF_sig <- res_OB_MCF %>%
arrange(padj) %>%
filter(padj < 0.1) %>%
dplyr::select(c(padj, baseMean, log2FoldChange)) %>%
mutate(across(c(1:3), ~round(.x, digits=3)))
res_OB_MCF_sig
dat <- norm.dat.k2$set
#dat <- dat[,dat$batch %in% c("1","2","3","5","6","7","8","9")]  ## Drop outlier batch 4
dat_ob <- dat[,dat$status_ob %in% c("Lean","Obese")]  ## drop overweight samples, keep obese + lean
pData_2 <- pData(dat_ob)
pData_2 <- pData_2 %>% as_tibble() %>% mutate(milk_col_factor = as.factor(ntile(milk_col_dt, 4))) #Quartile bins of collection date
dds_ob <- DESeqDataSetFromMatrix(countData = counts(dat_ob[26:823,]),
colData = pData_2,
design = ~ W_1 + W_2 + milk_col_factor + status_ob)
dds_ob <- DESeq(dds_ob, fitType = 'local')
res_OB_MCF <- as.data.frame(results(dds_ob,contrast = c('status_ob','Obese','Lean')))
## Table of top DE genes
res_OB_MCF_sig <- res_OB_MCF %>%
arrange(padj) %>%
filter(padj < 0.1) %>%
dplyr::select(c(padj, baseMean, log2FoldChange)) %>%
mutate(across(c(1:3), ~round(.x, digits=3)))
res_OB_MCF_sig
dat <- norm.dat.k2$set
dat_drop4 <- dat[,dat$batch %in% c("1","2","3","5","6","7","8","9")]
pData_drop4 <- pData(dat_drop4)
pData_drop4 <- pData_drop4 %>% as_tibble() %>% mutate(milk_col_factor = as.factor(milk_col_dt < 40)) #
dds_drop4_day40 <- DESeqDataSetFromMatrix(countData = counts(dat_drop4[26:823,]),
colData = pData_drop4,
design = ~ W_1 + W_2 + status_ov + milk_col_factor)
dat <- norm.dat.k2$set
dat_drop4 <- dat[,dat$batch %in% c("1","2","3","5","6","7","8","9")]
pData_drop4 <- pData(dat_drop4)
pData_drop4 <- pData_drop4 %>% as_tibble() %>% mutate(milk_col_factor = as.factor(milk_col_dt < 40)) #
dds_drop4_day40 <- DESeqDataSetFromMatrix(countData = counts(dat_drop4[26:823,]),
colData = pData_drop4,
design = ~ W_1 + W_2 + status_ob + milk_col_factor)
dds_drop4_day40 <- DESeq(dds_drop4_day40, fit='local')
res_OB_drop4_day40 <- as.data.frame(results(dds_drop4_day40,contrast = c('milk_col_factor','TRUE','FALSE')))
## Table of top DE genes
res_OB_drop4_day40 <- res_OB_drop4_day40 %>%
arrange(padj) %>%
filter(padj < 0.1) %>%
dplyr::select(c(padj, baseMean, log2FoldChange)) %>%
mutate(across(c(1:3), ~round(.x, digits=3)))
res_OB_drop4_day40
df <- res_OB_MCF_sig %>% mutate(gene_name = rownames(.)) %>% filter(padj < 0.1)
p <- do_vol_plot(df = df, sig = 0.05, fc = 0.3, size = 2)
p <- p + ggtitle("")
p
df <- res_OB_MCF_sig %>% mutate(gene_name = rownames(.)) %>% filter(padj < 0.1)
p <- do_vol_plot(df = df, sig = 0.05, fc = 0.3, size = 2)
p <- p + ggtitle("Volcano Plot: Obese vs Lean Controlled for Postpartum Date")
p
df <- res_OB_drop4_day40 %>% mutate(gene_name = rownames(.)) %>% filter(padj < 0.1)
p <- do_vol_plot(df = df, sig = 0.05, fc = 0.3, size = 2)
p <- p + ggtitle("Before Day 40 vs After Day 40, controlled for BMI; red = padj<0.05")
p
dat <- norm.dat.k2$set
#dat_drop4 <- dat[,dat$batch %in% c("1","2","3","5","6","7","8","9")]
dat <- dat[, dat$status_ob %in% c("Lean","Obese")]
pData <- pData(dat)
pData <- pData %>% as_tibble() %>% mutate(milk_col_factor = as.factor(milk_col_dt < 40)) #
dds_day40 <- DESeqDataSetFromMatrix(countData = counts(dat[26:823,]),
colData = pData,
design = ~ W_1 + W_2 + status_ob + milk_col_factor)
dds_day40 <- DESeq(dds_day40, fit='local')
res_day40 <- as.data.frame(results(dds_day40,contrast = c('milk_col_factor','TRUE','FALSE')))
## Table of top DE genes
res_day40 <- res_day40 %>%
arrange(padj) %>%
filter(padj < 0.1) %>%
dplyr::select(c(padj, baseMean, log2FoldChange)) %>%
mutate(across(c(1:3), ~round(.x, digits=3)))
res_day40
df <- res_day40 %>% mutate(gene_name = rownames(.)) %>% filter(padj < 0.1)
p <- do_vol_plot(df = df, sig = 0.05, fc = 0.3, size = 2)
p <- p + ggtitle("Before Day 40 vs After Day 40, controlled for BMI; red = padj<0.05")
p
View(res_OV)
knitr::opts_chunk$set(echo = TRUE)
## Format and plotting
library(ggrepel)
library(kableExtra)
library(pcaExplorer)
library(Vennerable)
require(ggplot2)
## Nanostring specific
library(RUVSeq)
library(NanoStringQCPro)
library(NanoNormIter)
## DE analysis
library(DESeq2)
library(limma)
library(matrixStats)
library(EnvStats)
## TidyR
library(tidyverse)
library(magrittr)
## Volcano Plot
do_vol_plot <- function(df, sig=0.05, fc=0.5, size = 4){
df_sig<- df %>% filter(padj < sig)
## genes with labels -- signficant,decreased expression and start with IGF
df_label<- df %>%
filter(padj < sig, abs(log2FoldChange) > fc)
#mutate(short_id = stringr::str_split(gene_id, "000000") %>% map_chr(.,2))
## plot
p <- ggplot(df, aes(log2FoldChange, -log10(padj)))  +
geom_point(size=0.8, color="black", alpha=.8) +
geom_point(size=0.8, data=df_sig, aes(log2FoldChange, -log10(padj)), colour="red") +
geom_text_repel(size= size,
colour="black",
segment.size=0.1,
nudge_x=0.06,
nudge_y=0.06,
data=df_label,
aes(log2FoldChange, -log10(padj), label=gene_name),
max.iter= 200,
point.padding = 0.15,
segment.alpha = 1,
box.padding=.15,
min.segment.length = unit(0.15, 'lines'),size=2.5) +
theme(
axis.text.x = element_text(size=12),
axis.text.y = element_text(size=12),
axis.title.x = element_text(size=14, margin = margin(t = 10, r = 0, b = 10, l = 0)),
axis.title.y = element_text(size=14, margin = margin(t = 0, r = 10, b = 0, l = 10)),
plot.margin =unit(c(.5,.5,.5,.5),"cm"),
plot.title = element_text(size = 11)
)
return (p)
}
# Function to add correlation coefficients
panel.cor <- function(x, y, digits = 2, prefix = "", cex.cor, ...) {
usr <- par("usr")
on.exit(par(usr))
par(usr = c(0, 1, 0, 1))
Cor <- abs(cor(x, y)) # Remove abs function if desired
txt <- paste0(prefix, format(c(Cor, 0.123456789), digits = digits)[1])
if(missing(cex.cor)) {
cex.cor <- 0.4 / strwidth(txt)
}
text(0.5, 0.5, txt,
cex = 1 + cex.cor * Cor) # Resize the text by level of correlation
}
#### THESE FUNCTIONS ARE IMPORTED BY 'NANONORMITER' PACKAGE
# FOR REFERENCE, HERE ARE THE QC CHECKS:
# imagingQC <- function(rcc){
#
#     fovRatio = as.numeric(rcc$Lane_Attributes[3]) / as.numeric(rcc$Lane_Attributes[2])
#     if (!(fovRatio > .75)) {return('Flag')}
#     if (fovRatio > .75) {return('No flag')}
#
# }
#
# #### INPUT: rcc - input from rcc (use readRcc from NanoStringQCPro)
# ####         low, high - the lower and upper limits for binding density
# #### OUTPUT: flag for binding density
#
# bindingDensityQC <- function(rcc,low,high){
#
#     bd = as.numeric(rcc$Lane_Attributes[6])
#     if(!(bd < high & bd > low)) {return('Flag')}
#     if (bd < high & bd > low) {return('No flag')}
#
#
# }
#
# #### INPUT: rcc - input from rcc (use readRcc from NanoStringQCPro)
# #### OUTPUT: flag for linearity for positive controls
#
# positiveLinQC <- function(rcc){
#
#     counts = rcc$Code_Summary
#     posControls = as.numeric(counts$Count[grepl('POS_',counts$Name)])
#     known = c(128,128/4,128/16,128/64,128/256,128/(256*4))
#     r2 = summary(lm(sort(posControls)~sort(known)))$r.squared
#     if(!(r2 > .95) | is.na(r2)) {return('Flag')}
#     if(r2 > .95) {return('No flag')}
#
# }
#
# #### INPUT: rcc - input from rcc (use readRcc from NanoStringQCPro)
# ####         numSD - number of standard deviations to calibrate the LOD
# #### OUTPUT: flag for limit of detection
#
# limitOfDetectionQC <- function(rcc,numSD = 0){
#
#     counts = rcc$Code_Summary
#     posE = as.numeric(counts$Count[counts$Name == 'POS_E'])
#     negControls = as.numeric(counts$Count[grepl('NEG',counts$Name)])
#     if(!(posE > mean(negControls) + numSD*sd(negControls))) {return('Flag')}
#     if (posE > mean(negControls) + numSD*sd(negControls)) {return('No flag')}
#
# }
##### HERE IS THE RUV CALCULATION AS IMPLEMENTED IN NANONORMITER()
# RUV_total <- function(raw,pData,fData,k,hkgenes = NULL,exclude = NULL){
#
#     library(RUVSeq)
#     library(DESeq2)
#     library(limma)
#     library(matrixStats)
#
#     if (!is.null(hkgenes)){
#
#         fData(set)$Class[rownames(set) %in% hkgenes] = 'Housekeeping'
#
#     }
#
#     fData = fData[rownames(raw),]
#     int = intersect(rownames(raw),rownames(fData))
#     fData = fData[int,]
#     raw = raw[int,]
#
#     set <- newSeqExpressionSet(as.matrix(round(raw)),
#                                phenoData=pData,
#                                featureData=fData)
#
#     cIdx <- rownames(set)[fData(set)$Class == "Housekeeping"]
#     cIdx = cIdx[!(cIdx %in% exclude)]
#     x <- as.factor(pData$Group)
#     set <- betweenLaneNormalization(set, which="upper")
#     set <- RUVg(set, cIdx, k=k)
#     dds <- DESeqDataSetFromMatrix(counts(set),colData=pData(set),design=~1)
#     rowData(dds) <- fData
#     dds <- estimateSizeFactors(dds)
#     dds <- estimateDispersionsGeneEst(dds)
#     cts <- counts(dds, normalized=TRUE)
#     disp <- pmax((rowVars(cts) - rowMeans(cts)),0)/rowMeans(cts)^2
#     mcols(dds)$dispGeneEst <- disp
#     dds <- estimateDispersionsFit(dds, fitType="mean")
#     vsd <- varianceStabilizingTransformation(dds, blind=FALSE)
#     mat <- assay(vsd)
#     covars <- as.matrix(colData(dds)[,grep("W",colnames(colData(dds))),drop=FALSE])
#     mat <- removeBatchEffect(mat, covariates=covars)
#     assay(vsd) <- mat
#     return(list(set = set,vsd = vsd))
#
# }
meta_df_full <- readxl::read_xlsx('cleaned_metadata.xlsx', sheet = 'Sheet1', col_names = TRUE, col_types = "guess")
meta_df <- meta_df_full %>% dplyr::select(c(`file name`, batch, `study ID`, Age, Race, `prepregnancy BMI`, `current  BMI`, `Breast milk colllection date post delivary`, `Delivery type`))
colnames(meta_df) <- c("filename","batch","SampleID","age","race","prepreg_BMI","curr_BMI","milk_col_dt", "delivery")
meta_df$batch[28:40] <- "4"  #fix the singleton batch
## Overweight >= 25.  Obese >=30.
meta_df <- meta_df %>%  dplyr::mutate(
status_ob = dplyr::case_when(
.data$prepreg_BMI < 25 ~ "Lean",
.data$prepreg_BMI >= 30 ~ "Obese",
(.data$prepreg_BMI >= 25 & .data$prepreg_BMI < 30) ~ "Overweight"
)
)
#getwd()
files.RCC = list.files(".", full.names = TRUE)
files.RCC = files.RCC[grepl('RCC',files.RCC)]
head(files.RCC)
ng = nrow(readRcc(files.RCC[1])$Code_Summary)
ncol = length(files.RCC)
raw_expression = as.data.frame(matrix(nrow = ng,ncol = length(files.RCC)+2))
colnames(raw_expression)[1:2] = c('Gene','Class')
pData = as.data.frame(matrix(nrow = length(files.RCC),ncol = 11))
colnames(pData) = c('BCAC_ID','SampleID','Owner','Comments','Date','GeneRLF','SystemAPF','imagingQC',
'bindingDensityQC','limitOfDetectionQC','positiveLinearityQC')
raw_expression[,1:2] = readRcc(files.RCC[1])$Code_Summary[,c(2,1)]
head(pData, 5)
head(raw_expression, 5)
## NOTE: I have to override the positiveLinQC function for this panel b/c it uses two types of positive controls and that confuses the grepl search.
positiveLinQC <- function(rcc){
counts = rcc$Code_Summary
#posControls = as.numeric(counts$Count[grepl('POS_',counts$Name)])
posControls = as.numeric(counts$Count[grepl('^POS_',counts$Name)])
known = c(128,128/4,128/16,128/64,128/256,128/(256*4))
r2 = summary(lm(sort(posControls)~sort(known)))$r.squared
if(!(r2 > .95) | is.na(r2)) {return('Flag')}
if(r2 > .95) {return('No flag')}
}
## Override this function to account for two types of Neg controls.
limitOfDetectionQC <- function(rcc,numSD = 0){
counts = rcc$Code_Summary
posE = as.numeric(counts$Count[counts$Name == 'POS_E'])
negControls = as.numeric(counts$Count[grepl('^NEG',counts$Name)])
if(!(posE > mean(negControls) + numSD*sd(negControls))) {return('Flag')}
if (posE > mean(negControls) + numSD*sd(negControls)) {return('No flag')}
}
##
## Populate pData and raw expr tables from RCC files
for (i in 1:length(files.RCC)){
#i = 1
print(i)
rcc = readRcc(files.RCC[i])
raw = rcc$Code_Summary
raw_expression[,i+2] = as.numeric(raw$Count)
#colnames(raw_expression)[i+2] = strsplit(files.RCC[i],'_')[[1]][2:4]
pData[i,2:7] = as.vector(rcc$Sample_Attributes)
pData$imagingQC[i] = imagingQC(rcc)
pData$bindingDensityQC[i] = bindingDensityQC(rcc,.05,2.25)
pData$limitOfDetectionQC[i] = limitOfDetectionQC(rcc)
pData$positiveLinearityQC[i] = positiveLinQC(rcc)
}
## Munge pData and metadata together; create treatment classes
pData$SampleID <- meta_df$SampleID
pData <- dplyr::left_join(pData, meta_df, by = "SampleID")
rownames(pData) <- pData$SampleID
colnames(raw_expression)[3:82] <- pData$SampleID
head(pData)
raw = raw_expression[,-c(1:2)]
fData = raw_expression[,c(1:2)]
rownames(raw) = fData$Gene
cIdx <- fData$Gene[fData$Class == "Housekeeping"]
pData$HK_Gene_Miss = colSums(raw[cIdx,] == 0)
rownames(fData) = fData$Gene
rownames(raw) = fData$Gene
#rownames(pData) = colnames(raw)
#
norm.dat.k2 <- NanoNormIter::RUV_total(raw,pData,fData,k = 2)
dat <- norm.dat.k2$set
#dat <- dat[,dat$batch %in% c("1","2","3","5","6","7","8","9")]  ## Drop outlier batch 4
dat_ob <- dat[,dat$status_ob %in% c("Lean","Obese")]  ## drop overweight samples, keep obese + lean
pData_2 <- pData(dat_ob)
pData_2 <- pData_2 %>% as_tibble() %>% mutate(milk_col_factor = as.factor(ntile(milk_col_dt, 4))) #Quartile bins of collection date
dds_ob <- DESeqDataSetFromMatrix(countData = counts(dat_ob[26:823,]),
colData = pData_2,
design = ~ W_1 + W_2 + milk_col_factor + status_ob)
dds_ob <- DESeq(dds_ob, fitType = 'local')
res_OB_MCF <- as.data.frame(results(dds_ob,contrast = c('status_ob','Obese','Lean')))
view(res_OB_MCF)
getwd()
write.csv(res_OB_MCF, file="DEGs_OB_MCF_Ver2_Mar2022.csv")
dat <- norm.dat.k2$set
#dat_drop4 <- dat[,dat$batch %in% c("1","2","3","5","6","7","8","9")]
dat <- dat[, dat$status_ob %in% c("Lean","Obese")]
pData <- pData(dat)
pData <- pData %>% as_tibble() %>% mutate(milk_col_factor = as.factor(milk_col_dt < 40)) #
dds_day40 <- DESeqDataSetFromMatrix(countData = counts(dat[26:823,]),
colData = pData,
design = ~ W_1 + W_2 + status_ob + milk_col_factor)
dds_day40 <- DESeq(dds_day40, fit='local')
res_day40 <- as.data.frame(results(dds_day40,contrast = c('milk_col_factor','TRUE','FALSE')))
view(res_day40)
write.csv(res_day40, file="DEGs_day40_postPartum_V2_Mar2022.csv")
