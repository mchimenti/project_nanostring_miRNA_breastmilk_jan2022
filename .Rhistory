for (i in 1:nrow(hk_raw)){
reg = glm.nb(as.numeric(hk_raw[i,]) ~ as.factor(pData$status))
pval[i] = coef(summary(reg))[2,4]
}
pval <- pval %>% as_tibble() %>% mutate(hkgene = rownames(hk_raw))
pval
neg_raw <- raw %>% filter(row.names(raw) %in% c("NEG_A","NEG_B","NEG_C","NEG_D","NEG_E","NEG_F","NEG_G","NEG_H"))
lod <- colMeans(neg_raw) - apply(neg_raw,1,sd)
num_endo_blod <- colSums(raw_expression[raw_expression$Class == "Endogenous1", -c(1:2)] < lod)
num_hk_blod <- colSums(raw_expression[raw_expression$Class == "Housekeeping", -c(1:2)] < lod)
num_endo_blod
ggbarplot(num_endo_blod)
ggbarplot(as.data.frame(num_endo_blod))
df <- as.data.frame(below_lim = num_endo_blod, batch = pData$batch)
df <- data.frame(below_lim = num_endo_blod, batch = pData$batch)
df
ggbarplot(df, y=below_lim, color =batch)
ggbarplot(df, y="below_lim", color="batch")
df <- data.frame(below_lim = num_endo_blod, batch = pData$batch, name=pData$SampleID)
df
ggbarplot(df, y="below_lim", x="name", color="batch")
ggbarplot(df, y="below_lim", x="name", color="batch", fill="batch")
rcc = readRcc(files.RCC[1])
counts = rcc$Code_Summary
posE = as.numeric(counts$Count[counts$Name == 'POS_E'])
posE
negControls = as.numeric(counts$Count[grepl('NEG',counts$Name)])
negControls
head(raw, 10)
head(raw, 24)
rownames(raw)
negControls
negControls = as.numeric(counts$Count[grepl('^NEG',counts$Name)])
negControls
## NOTE: I have to override the positiveLinQC function for this panel b/c it uses two types of positive controls and that confuses the grepl search.
positiveLinQC <- function(rcc){
counts = rcc$Code_Summary
#posControls = as.numeric(counts$Count[grepl('POS_',counts$Name)])
posControls = as.numeric(counts$Count[grepl('^POS_',counts$Name)])
known = c(128,128/4,128/16,128/64,128/256,128/(256*4))
r2 = summary(lm(sort(posControls)~sort(known)))$r.squared
if(!(r2 > .95) | is.na(r2)) {return('Flag')}
if(r2 > .95) {return('No flag')}
}
## Override this function to account for two types of Neg controls.
limitOfDetectionQC <- function(rcc,numSD = 0){
counts = rcc$Code_Summary
posE = as.numeric(counts$Count[counts$Name == 'POS_E'])
negControls = as.numeric(counts$Count[grepl('^NEG',counts$Name)])
if(!(posE > mean(negControls) + numSD*sd(negControls))) {return('Flag')}
if (posE > mean(negControls) + numSD*sd(negControls)) {return('No flag')}
}
##
## Populate pData and raw expr tables from RCC files
for (i in 1:length(files.RCC)){
#i = 1
print(i)
rcc = readRcc(files.RCC[i])
raw = rcc$Code_Summary
raw_expression[,i+2] = as.numeric(raw$Count)
#colnames(raw_expression)[i+2] = strsplit(files.RCC[i],'_')[[1]][2:4]
pData[i,2:7] = as.vector(rcc$Sample_Attributes)
pData$imagingQC[i] = imagingQC(rcc)
pData$bindingDensityQC[i] = bindingDensityQC(rcc,.05,2.25)
pData$limitOfDetectionQC[i] = limitOfDetectionQC(rcc)
pData$positiveLinearityQC[i] = positiveLinQC(rcc)
}
## Munge pData and metadata together; create treatment classes
pData$SampleID <- meta_df$SampleID
pData <- dplyr::left_join(pData, meta_df, by = "SampleID")
rownames(pData) <- pData$SampleID
colnames(raw_expression)[3:82] <- pData$SampleID
head(pData)
pData
pData$limitOfDetectionQC
posE
raw
head(raw)
str(rraw)
str(raw)
knitr::opts_chunk$set(echo = TRUE)
## Format and plotting
library(ggrepel)
library(kableExtra)
library(pcaExplorer)
library(Vennerable)
require(ggplot2)
## Nanostring specific
library(RUVSeq)
library(NanoStringQCPro)
library(NanoNormIter)
## DE analysis
library(DESeq2)
library(limma)
library(matrixStats)
library(EnvStats)
## TidyR
library(tidyverse)
library(magrittr)
## Volcano Plot
do_vol_plot <- function(df, sig=0.05, fc=0.5, size = 4){
df_sig<- df %>% filter(padj < sig)
## genes with labels -- signficant,decreased expression and start with IGF
df_label<- df %>%
filter(padj < sig, abs(log2FoldChange) > fc)
#mutate(short_id = stringr::str_split(gene_id, "000000") %>% map_chr(.,2))
## plot
p <- ggplot(df, aes(log2FoldChange, -log10(padj)))  +
geom_point(size=0.8, color="black", alpha=.8) +
geom_point(size=0.8, data=df_sig, aes(log2FoldChange, -log10(padj)), colour="red") +
geom_text_repel(size= size,
colour="black",
segment.size=0.1,
nudge_x=0.06,
nudge_y=0.06,
data=df_label,
aes(log2FoldChange, -log10(padj), label=gene_name),
max.iter= 200,
point.padding = 0.15,
segment.alpha = 1,
box.padding=.15,
min.segment.length = unit(0.15, 'lines'),size=2.5) +
theme(
axis.text.x = element_text(size=12),
axis.text.y = element_text(size=12),
axis.title.x = element_text(size=14, margin = margin(t = 10, r = 0, b = 10, l = 0)),
axis.title.y = element_text(size=14, margin = margin(t = 0, r = 10, b = 0, l = 10)),
plot.margin =unit(c(.5,.5,.5,.5),"cm"),
plot.title = element_text(size = 11)
)
return (p)
}
# Function to add correlation coefficients
panel.cor <- function(x, y, digits = 2, prefix = "", cex.cor, ...) {
usr <- par("usr")
on.exit(par(usr))
par(usr = c(0, 1, 0, 1))
Cor <- abs(cor(x, y)) # Remove abs function if desired
txt <- paste0(prefix, format(c(Cor, 0.123456789), digits = digits)[1])
if(missing(cex.cor)) {
cex.cor <- 0.4 / strwidth(txt)
}
text(0.5, 0.5, txt,
cex = 1 + cex.cor * Cor) # Resize the text by level of correlation
}
#### THESE FUNCTIONS ARE IMPORTED BY 'NANONORMITER' PACKAGE
# FOR REFERENCE, HERE ARE THE QC CHECKS:
# imagingQC <- function(rcc){
#
#     fovRatio = as.numeric(rcc$Lane_Attributes[3]) / as.numeric(rcc$Lane_Attributes[2])
#     if (!(fovRatio > .75)) {return('Flag')}
#     if (fovRatio > .75) {return('No flag')}
#
# }
#
# #### INPUT: rcc - input from rcc (use readRcc from NanoStringQCPro)
# ####         low, high - the lower and upper limits for binding density
# #### OUTPUT: flag for binding density
#
# bindingDensityQC <- function(rcc,low,high){
#
#     bd = as.numeric(rcc$Lane_Attributes[6])
#     if(!(bd < high & bd > low)) {return('Flag')}
#     if (bd < high & bd > low) {return('No flag')}
#
#
# }
#
# #### INPUT: rcc - input from rcc (use readRcc from NanoStringQCPro)
# #### OUTPUT: flag for linearity for positive controls
#
# positiveLinQC <- function(rcc){
#
#     counts = rcc$Code_Summary
#     posControls = as.numeric(counts$Count[grepl('POS_',counts$Name)])
#     known = c(128,128/4,128/16,128/64,128/256,128/(256*4))
#     r2 = summary(lm(sort(posControls)~sort(known)))$r.squared
#     if(!(r2 > .95) | is.na(r2)) {return('Flag')}
#     if(r2 > .95) {return('No flag')}
#
# }
#
# #### INPUT: rcc - input from rcc (use readRcc from NanoStringQCPro)
# ####         numSD - number of standard deviations to calibrate the LOD
# #### OUTPUT: flag for limit of detection
#
# limitOfDetectionQC <- function(rcc,numSD = 0){
#
#     counts = rcc$Code_Summary
#     posE = as.numeric(counts$Count[counts$Name == 'POS_E'])
#     negControls = as.numeric(counts$Count[grepl('NEG',counts$Name)])
#     if(!(posE > mean(negControls) + numSD*sd(negControls))) {return('Flag')}
#     if (posE > mean(negControls) + numSD*sd(negControls)) {return('No flag')}
#
# }
##### HERE IS THE RUV CALCULATION AS IMPLEMENTED IN NANONORMITER()
# RUV_total <- function(raw,pData,fData,k,hkgenes = NULL,exclude = NULL){
#
#     library(RUVSeq)
#     library(DESeq2)
#     library(limma)
#     library(matrixStats)
#
#     if (!is.null(hkgenes)){
#
#         fData(set)$Class[rownames(set) %in% hkgenes] = 'Housekeeping'
#
#     }
#
#     fData = fData[rownames(raw),]
#     int = intersect(rownames(raw),rownames(fData))
#     fData = fData[int,]
#     raw = raw[int,]
#
#     set <- newSeqExpressionSet(as.matrix(round(raw)),
#                                phenoData=pData,
#                                featureData=fData)
#
#     cIdx <- rownames(set)[fData(set)$Class == "Housekeeping"]
#     cIdx = cIdx[!(cIdx %in% exclude)]
#     x <- as.factor(pData$Group)
#     set <- betweenLaneNormalization(set, which="upper")
#     set <- RUVg(set, cIdx, k=k)
#     dds <- DESeqDataSetFromMatrix(counts(set),colData=pData(set),design=~1)
#     rowData(dds) <- fData
#     dds <- estimateSizeFactors(dds)
#     dds <- estimateDispersionsGeneEst(dds)
#     cts <- counts(dds, normalized=TRUE)
#     disp <- pmax((rowVars(cts) - rowMeans(cts)),0)/rowMeans(cts)^2
#     mcols(dds)$dispGeneEst <- disp
#     dds <- estimateDispersionsFit(dds, fitType="mean")
#     vsd <- varianceStabilizingTransformation(dds, blind=FALSE)
#     mat <- assay(vsd)
#     covars <- as.matrix(colData(dds)[,grep("W",colnames(colData(dds))),drop=FALSE])
#     mat <- removeBatchEffect(mat, covariates=covars)
#     assay(vsd) <- mat
#     return(list(set = set,vsd = vsd))
#
# }
meta_df_full <- readxl::read_xlsx('cleaned_metadata.xlsx', sheet = 'Sheet1', col_names = TRUE, col_types = "guess")
meta_df <- meta_df_full %>% dplyr::select(c(`file name`, batch, `study ID`, Age, Race, `prepregnancy BMI`, `current  BMI`, `Breast milk colllection date post delivary`, `Delivery type`))
colnames(meta_df) <- c("filename","batch","SampleID","age","race","prepreg_BMI","curr_BMI","milk_col_dt", "delivery")
meta_df$batch[28:40] <- "4"  #fix the singleton batch
library(ggpubr)
# Box plots with jittered points
# :::::::::::::::::::::::::::::::::::::::::::::::::::
# Change outline colors by groups: dose
# Use custom color palette
# Add jitter points and change the shape by groups
p <- ggboxplot(meta_df, x = "delivery", y = "prepreg_BMI",
color = "delivery", palette =c("#00AFBB", "#E7B800","#FC4E07"),
add = "jitter")
my_comps <- list( c("vaginal", "vbac"), c("vaginal","c-sec"), c("vbac","c-sec"))
p <- p + stat_compare_means(comparisons = my_comps) + stat_compare_means(label.y=50)
p
p1 <- ggboxplot(meta_df, x = "batch", y = "prepreg_BMI",
color = "batch",
add = "jitter")
p1
p2 <- ggboxplot(meta_df, x = "batch", y = "curr_BMI",
color = "batch",
add = "jitter")
p2
meta_df <- meta_df %>% dplyr::mutate(
status = dplyr::case_when(
.data$prepreg_BMI < 24.25 ~ "Lean",
.data$prepreg_BMI >=24.25 ~ "Overweight",
TRUE ~ NA_character_
)
)
p3 <- ggplot(meta_df, aes(y=batch, fill=status)) + geom_bar(position="fill") + ggtitle("Fraction Overweight by Batch; BMI > 24.25")
p3
df <- meta_df %>% dplyr::select(c(batch,age,prepreg_BMI,curr_BMI,milk_col_dt)) %>% mutate_at(vars(batch),factor) %>% as.data.frame()
groups <- df[,1]
pairs(df[,2:5],                     # Data frame of variables
labels = colnames(df[,2:5]),  # Variable names
pch = 21,                 # Pch symbol
bg = rainbow(9)[groups],  # Background color of the symbol (pch 21 to 25)
col = rainbow(9)[groups], # Border color of the symbol
main = "Breastmilk dataset (batch=color)",    # Title of the plot
row1attop = TRUE,         # If FALSE, changes the direction of the diagonal
gap = 1,                  # Distance between subplots
cex.labels = NULL,        # Size of the diagonal text
font.labels = 1,
lower.panel = panel.smooth,
upper.panel = panel.cor)          # Font style of the diagonal text
# Density plot with mean lines and marginal rug
# :::::::::::::::::::::::::::::::::::::::::::::::::::
# Change outline and fill colors by groups ("sex")
# Use custom palette
p <- gghistogram(meta_df, x = "age",
add = "mean", rug = TRUE, color = "blue")
p
p <- ggdensity(meta_df, x = "prepreg_BMI",
add = "mean", rug = TRUE, color = "blue")
p
p <- ggdensity(meta_df, x = "curr_BMI",
add = "mean", rug = TRUE, color = "blue")
p
#getwd()
files.RCC = list.files(".", full.names = TRUE)
files.RCC = files.RCC[grepl('RCC',files.RCC)]
head(files.RCC)
ng = nrow(readRcc(files.RCC[1])$Code_Summary)
ncol = length(files.RCC)
raw_expression = as.data.frame(matrix(nrow = ng,ncol = length(files.RCC)+2))
colnames(raw_expression)[1:2] = c('Gene','Class')
pData = as.data.frame(matrix(nrow = length(files.RCC),ncol = 11))
colnames(pData) = c('BCAC_ID','SampleID','Owner','Comments','Date','GeneRLF','SystemAPF','imagingQC',
'bindingDensityQC','limitOfDetectionQC','positiveLinearityQC')
raw_expression[,1:2] = readRcc(files.RCC[1])$Code_Summary[,c(2,1)]
head(pData, 5)
head(raw_expression, 5)
## NOTE: I have to override the positiveLinQC function for this panel b/c it uses two types of positive controls and that confuses the grepl search.
positiveLinQC <- function(rcc){
counts = rcc$Code_Summary
#posControls = as.numeric(counts$Count[grepl('POS_',counts$Name)])
posControls = as.numeric(counts$Count[grepl('^POS_',counts$Name)])
known = c(128,128/4,128/16,128/64,128/256,128/(256*4))
r2 = summary(lm(sort(posControls)~sort(known)))$r.squared
if(!(r2 > .95) | is.na(r2)) {return('Flag')}
if(r2 > .95) {return('No flag')}
}
## Override this function to account for two types of Neg controls.
limitOfDetectionQC <- function(rcc,numSD = 0){
counts = rcc$Code_Summary
posE = as.numeric(counts$Count[counts$Name == 'POS_E'])
negControls = as.numeric(counts$Count[grepl('^NEG',counts$Name)])
if(!(posE > mean(negControls) + numSD*sd(negControls))) {return('Flag')}
if (posE > mean(negControls) + numSD*sd(negControls)) {return('No flag')}
}
##
## Populate pData and raw expr tables from RCC files
for (i in 1:length(files.RCC)){
#i = 1
print(i)
rcc = readRcc(files.RCC[i])
raw = rcc$Code_Summary
raw_expression[,i+2] = as.numeric(raw$Count)
#colnames(raw_expression)[i+2] = strsplit(files.RCC[i],'_')[[1]][2:4]
pData[i,2:7] = as.vector(rcc$Sample_Attributes)
pData$imagingQC[i] = imagingQC(rcc)
pData$bindingDensityQC[i] = bindingDensityQC(rcc,.05,2.25)
pData$limitOfDetectionQC[i] = limitOfDetectionQC(rcc)
pData$positiveLinearityQC[i] = positiveLinQC(rcc)
}
## Munge pData and metadata together; create treatment classes
pData$SampleID <- meta_df$SampleID
pData <- dplyr::left_join(pData, meta_df, by = "SampleID")
rownames(pData) <- pData$SampleID
colnames(raw_expression)[3:82] <- pData$SampleID
head(pData)
pData[,7:10]
raw = raw_expression[,-c(1:2)]
fData = raw_expression[,c(1:2)]
rownames(raw) = fData$Gene
cIdx <- fData$Gene[fData$Class == "Housekeeping"]
pData$HK_Gene_Miss = colSums(raw[cIdx,] == 0)
rownames(fData) = fData$Gene
rownames(raw) = fData$Gene
#rownames(pData) = colnames(raw)
## making variance stabilized raw counts for later PCA plotting
#dds_raw_counts <- DESeqDataSetFromMatrix(as.matrix(raw),colData=pData,design=~Group)
#vst_raw_counts <- DESeq2::varianceStabilizingTransformation(dds_raw_counts)
#### CHECK IF housekeeping Genes ARE ASSOCIATED WITH PRIMARY PHENO
hk_raw = raw[cIdx,]
pval = vector(length = nrow(hk_raw))
require(MASS)
for (i in 1:nrow(hk_raw)){
reg = glm.nb(as.numeric(hk_raw[i,]) ~ as.factor(pData$status))
pval[i] = coef(summary(reg))[2,4]
}
pval <- pval %>% as_tibble() %>% mutate(hkgene = rownames(hk_raw))
pval
neg_raw <- raw %>% filter(row.names(raw) %in% c("NEG_A","NEG_B","NEG_C","NEG_D","NEG_E","NEG_F","NEG_G","NEG_H"))
lod <- colMeans(neg_raw) - apply(neg_raw,1,sd)
num_endo_blod <- colSums(raw_expression[raw_expression$Class == "Endogenous1", -c(1:2)] < lod)
num_hk_blod <- colSums(raw_expression[raw_expression$Class == "Housekeeping", -c(1:2)] < lod)
## Check the BLOD numbers by batch
df <- data.frame(below_lim = num_endo_blod, batch = pData$batch, name=pData$SampleID)
p <- ggbarplot(df, y="below_lim", x="name", color="batch", fill="batch")
p <- p + ggtitle("Number Endogenous miRNAs Below Limit of Detection by Batch")
p
fData
pData
## k = 1,2, and 3
## k is the number of sources of technical confounding (i.e., suspected batches)
norm.dat.k1 <- NanoNormIter::RUV_total(raw,pData,fData,k = 1)
norm.dat.k2 <- NanoNormIter::RUV_total(raw,pData,fData,k = 2)
norm.dat.k2 <- NanoNormIter::RUV_total(raw,pData,fData,k = 2)
norm.dat.k3 <- NanoNormIter::RUV_total(raw,pData,fData,k = 3)
## Raw data
EDASeq::plotRLE(as.matrix(raw), cex.lab=0.5)
## K=1
EDASeq::plotRLE(norm.dat.k1$set)
## K=2
EDASeq::plotRLE(norm.dat.k2$set)
## K=3
EDASeq::plotRLE(norm.dat.k3$set)
## K=1
p < EDASeq::plotRLE(norm.dat.k1$set)
## K=1
p <- EDASeq::plotRLE(norm.dat.k1$set)
p
?plotRLE
## Raw data
# making variance stabilized raw counts for later PCA plotting
dds_raw_counts <- DESeqDataSetFromMatrix(as.matrix(raw),colData=pData,design=~status)
vst_raw_counts <- DESeq2::varianceStabilizingTransformation(dds_raw_counts)
pcaExplorer::pcaplot(vst_raw_counts, intgroup = "status", ellipse = FALSE, text_labels = FALSE)
pcaExplorer::pcaplot(vst_raw_counts, intgroup = c("status","batch"), ellipse = FALSE, text_labels = FALSE)
pcaExplorer::pcaplot(vst_raw_counts, intgroup = "batch", ellipse = FALSE, text_labels = FALSE)
## RUVg norm, k=1
pcaExplorer::pcaplot(norm.dat.k1$vsd, intgroup = "batch", ellipse = FALSE, text_labels = FALSE)
## RUVg norm, k=2
pcaExplorer::pcaplot(norm.dat.k2$vsd, intgroup = "batch", ellipse = FALSE, text_labels = FALSE)
pcaExplorer::pcaplot(norm.dat.k2$vsd, intgroup = "status", ellipse = FALSE, text_labels = FALSE)
## RUVg norm, k=1
pcaExplorer::pcaplot(norm.dat.k1$vsd, intgroup = "batch", ellipse = FALSE, text_labels = FALSE)
pcaExplorer::pcaplot(norm.dat.k1$vsd, intgroup = "status", ellipse = FALSE, text_labels = FALSE)
## RUVg norm, k=3
pcaExplorer::pcaplot(norm.dat.k3$vsd, intgroup = "batch", ellipse = FALSE, text_labels = FALSE)
pcaExplorer::pcaplot(norm.dat.k3$vsd, intgroup = "status", ellipse = FALSE, text_labels = FALSE)
## RUVg norm, k=2
pcaExplorer::pcaplot(norm.dat.k2$vsd, intgroup = "batch", ellipse = FALSE, text_labels = FALSE)
str(norm.dat.k2$set)
norm.dat.k2$set
expr(norm.dat.k2$set)
counts(norm.dat.k2$set)
counts(norm.dat.k2$set)[1:20,1:2]
counts(norm.dat.k2$set)[1:25,1:2]
counts(norm.dat.k2$set)[1:30,1:2]
counts(norm.dat.k2$set)[1:26,1:2]
counts(norm.dat.k2$set)[700:,1:2]
counts(norm.dat.k2$set)[700:800,1:2]
counts(norm.dat.k2$set)[700:888,1:2]
counts(norm.dat.k2$set)[700:863,1:2]
counts(norm.dat.k2$set)[700:860,1:2]
counts(norm.dat.k2$set)
str(counts(norm.dat.k2$set))
counts(norm.dat.k2$set)[800:828,]
counts(norm.dat.k2$set)[800:828,1:2]
pData
pData(norm.dat.k2$set)
dds <- DESeqDataSetFromMatrix(countData = counts(norm.dat.k2$set[26:828,]),
colData = pData(norm.dat.k2$set),
design = ~ W_1 + W_2 + status)
dds <- DESeq(dds)
pData
res_OV <- as.data.frame(results(dds,contrast = c('status','Overweight','Lean')))
## Table of top DE genes
res_OV %>%
arrange(padj) %>%
filter(padj < 0.001) %>%
dplyr::select(c(padj, baseMean, log2FoldChange)) %>%
mutate(across(c(1:3), ~round(.x, digits=3))) %>%
kableExtra::kable()
## Table of top DE genes
res_OV %>%
arrange(padj) %>%
filter(padj < 0.1) %>%
dplyr::select(c(padj, baseMean, log2FoldChange)) %>%
mutate(across(c(1:3), ~round(.x, digits=3))) %>%
kableExtra::kable()
## Count plots of individual top DE genes
plotCounts(dds, "hsa-miR-642a-3p|0", intgroup = "status")
plotCounts(dds, "hsa-miR-630|0", intgroup = "status")
plotCounts(dds, "hsa-miR-575|0", intgroup = "status")
dds <- DESeqDataSetFromMatrix(countData = counts(norm.dat.k2$set[26:828,]),
colData = pData(norm.dat.k2$set),
design = ~ W_1 + W_2 + batch + status)
dds <- DESeq(dds)
res_OV <- as.data.frame(results(dds,contrast = c('status','Overweight','Lean')))
## Table of top DE genes
res_OV %>%
arrange(padj) %>%
filter(padj < 0.1) %>%
dplyr::select(c(padj, baseMean, log2FoldChange)) %>%
mutate(across(c(1:3), ~round(.x, digits=3))) %>%
kableExtra::kable()
plotCounts(dds, "hsa-miR-223-3p|0", intgroup = "status")
dds <- DESeqDataSetFromMatrix(countData = counts(norm.dat.k2$set[26:828,]),
colData = pData(norm.dat.k2$set),
design = ~ W_1 + W_2 + status)
dds <- DESeq(dds)
res_OV <- as.data.frame(results(dds,contrast = c('status','Overweight','Lean')))
## Table of top DE genes
res_OV %>%
arrange(padj) %>%
filter(padj < 0.1) %>%
dplyr::select(c(padj, baseMean, log2FoldChange)) %>%
mutate(across(c(1:3), ~round(.x, digits=3))) %>%
kableExtra::kable()
## Count plots of individual top DE genes
plotCounts(dds, "hsa-miR-642a-3p|0", intgroup = "status")
plotCounts(dds, "hsa-miR-630|0", intgroup = "status")
plotCounts(dds, "hsa-miR-575|0", intgroup = "status")
plotCounts(dds, "hsa-miR-223-3p|0", intgroup = "status")
meta_df <- meta_df %>% dplyr::mutate(
status_ov = dplyr::case_when(
.data$prepreg_BMI < 24.25 ~ "Lean",
.data$prepreg_BMI >=24.25 ~ "Overweight",
TRUE ~ NA_character_
)
) %>% dplyr::mutate(
status_ob = dplyr::case_when(
.data$prepreg_BMI < 24.25 ~ "Lean",
.data$prepreg_BMI > 30 ~ "Obese",
TRUE ~ NA_character_
)
)
meta_df
