---
title: "NanoString NCounter analysis: Breastmilk miRNA Obese vs Normals"
author: "Michael S Chimenti"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    df_print: paged
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: true
    code_folding: hide
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Introduction

## Project Summary 

**Our central hypothesis is that altered breast milk EV (bEV)-miRNA profiles in obese mothers affect the gene expression of intestinal epithelial cells (IECs), which might be associated with unfavorable health outcomes in children. Our long-term goal is to promote the health and development of children by improving the quality of breast milk through interventions and therapeutic strategies. The objectives of this study to achieve the long-term goal are 1) to understand the physiological roles of bEVs associated with maternal obesity, and 2) to establish a research team investigating bEVs with collaborators for the further studies. To attain the overall objectives, we propose the following specific aims:

Aim1. To determine differentially expressed bEV-miRNAs in obese mothers; We will recruit normal weight mothers and overweight/obese mothers and who have delivered a baby in the past one month. EV-miRNA expression profile will be analyzed with Nanostring Human miRNA Expression Panel. It will allow us to screen 798 biologically relevant miRNAs, which will enable us to find novel biomarkers related to maternal obesity. Our working hypothesis is that immune-response and metabolism-related miRNAs are altered in overweight/obese mother breast milk.
**

## Methods 

Nanostring NCounter data were obtained as “RCC” format files. These were imported into R with 'readRcc' function from the NanoStringQCPro package (Bioconductor; https://www.bioconductor.org/packages/release/bioc/html/NanoStringQCPro.html; Bourgon et. al.).  Here, we follow the NanoString RUV normalization procedure outlined in Love, et. al (ref), for quality control checks and iterative RUVg normalization (Risso, et. al.).  All samples passed QC checks and were included in the analysis.  After visualization of the normalized data with RLE and PCA plots, RUVg-normalized data (k=2) was chosen for downstream DEG analysis.  A DESeq2 'dds' object was created from the normalized data using ‘DESeqDataSetFromMatrix’ with design conditioned on a grouped factor (genotype and FPI).  Pathway and GO term enrichment was carried out using ‘ClusterProfiler’ (ref).  R code for the analysis is available on Github.    

Nickles D, Sandmann T, Ziman R, Bourgon R (2021). NanoStringQCPro: Quality metrics and data processing methods for NanoString mRNA gene expression data. R package version 1.26.0.

Bhattacharya A, Hamilton AM, Furberg H, et al. An approach for normalization and quality control for NanoString RNA expression data. Brief Bioinform. 2021;22(3):bbaa163. doi:10.1093/bib/bbaa163

Risso D, Ngai J, Speed T, Dudoit S (2014). “Normalization of RNA-seq data using factor analysis of control genes or samples.” Nature Biotechnology, 32(9), 896–902. In press, http://www.nature.com/nbt/journal/v32/n9/full/nbt.2931.html.

Love MI, Huber W, Anders S (2014). “Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2.” Genome Biology, 15, 550. doi: 10.1186/s13059-014-0550-8.

## Library imports 
Click the "Code" button to see hidden code.  
```{r, imports, warning=FALSE, message=FALSE, class.source = 'fold-show'}

## Format and plotting 
library(ggrepel)
library(kableExtra)
library(pcaExplorer)
library(Vennerable)
require(ggplot2)

## Nanostring specific 
library(RUVSeq)
library(NanoStringQCPro)
library(NanoNormIter)


## DE analysis 
library(DESeq2)
library(limma)
library(matrixStats)
library(EnvStats)

## TidyR
library(tidyverse)
library(magrittr)

```

## Function definitions 

```{r, function_defs}
## Volcano Plot

do_vol_plot <- function(df, sig=0.05, fc=0.5, size = 4){
  
  df_sig<- df %>% filter(padj < sig)
  
  ## genes with labels -- signficant,decreased expression and start with IGF
  
  df_label<- df %>% 
              filter(padj < sig, abs(log2FoldChange) > fc)
              #mutate(short_id = stringr::str_split(gene_id, "000000") %>% map_chr(.,2))
  
  
  ## plot
  
  p <- ggplot(df, aes(log2FoldChange, -log10(padj)))  +
      geom_point(size=0.8, color="black", alpha=.8) + 
      geom_point(size=0.8, data=df_sig, aes(log2FoldChange, -log10(padj)), colour="red") +
       geom_text_repel(size= size, 
                    colour="black",
                    segment.size=0.1, 
                    nudge_x=0.06, 
                    nudge_y=0.06, 
                    data=df_label,
                    aes(log2FoldChange, -log10(padj), label=gene_name), 
                    max.iter= 200, 
                    point.padding = 0.15, 
                    segment.alpha = 1, 
                    box.padding=.15,
                    min.segment.length = unit(0.15, 'lines'),size=2.5) +
    theme(
      axis.text.x = element_text(size=12),
      axis.text.y = element_text(size=12),
      axis.title.x = element_text(size=14, margin = margin(t = 10, r = 0, b = 10, l = 0)),
      axis.title.y = element_text(size=14, margin = margin(t = 0, r = 10, b = 0, l = 10)),
      plot.margin =unit(c(.5,.5,.5,.5),"cm"),
      plot.title = element_text(size = 11)
    )
  
  return (p)
}

# Function to add correlation coefficients
panel.cor <- function(x, y, digits = 2, prefix = "", cex.cor, ...) {
    usr <- par("usr")
    on.exit(par(usr))
    par(usr = c(0, 1, 0, 1))
    Cor <- abs(cor(x, y)) # Remove abs function if desired
    txt <- paste0(prefix, format(c(Cor, 0.123456789), digits = digits)[1])
    if(missing(cex.cor)) {
        cex.cor <- 0.4 / strwidth(txt)
    }
    text(0.5, 0.5, txt,
         cex = 1 + cex.cor * Cor) # Resize the text by level of correlation
}

#### THESE FUNCTIONS ARE IMPORTED BY 'NANONORMITER' PACKAGE
# FOR REFERENCE, HERE ARE THE QC CHECKS: 
# imagingQC <- function(rcc){
# 
#     fovRatio = as.numeric(rcc$Lane_Attributes[3]) / as.numeric(rcc$Lane_Attributes[2])
#     if (!(fovRatio > .75)) {return('Flag')}
#     if (fovRatio > .75) {return('No flag')}
# 
# }
# 
# #### INPUT: rcc - input from rcc (use readRcc from NanoStringQCPro)
# ####         low, high - the lower and upper limits for binding density
# #### OUTPUT: flag for binding density
# 
# bindingDensityQC <- function(rcc,low,high){
# 
#     bd = as.numeric(rcc$Lane_Attributes[6])
#     if(!(bd < high & bd > low)) {return('Flag')}
#     if (bd < high & bd > low) {return('No flag')}
# 
# 
# }
# 
# #### INPUT: rcc - input from rcc (use readRcc from NanoStringQCPro)
# #### OUTPUT: flag for linearity for positive controls
# 
# positiveLinQC <- function(rcc){
# 
#     counts = rcc$Code_Summary
#     posControls = as.numeric(counts$Count[grepl('POS_',counts$Name)])
#     known = c(128,128/4,128/16,128/64,128/256,128/(256*4))
#     r2 = summary(lm(sort(posControls)~sort(known)))$r.squared
#     if(!(r2 > .95) | is.na(r2)) {return('Flag')}
#     if(r2 > .95) {return('No flag')}
# 
# }
# 
# #### INPUT: rcc - input from rcc (use readRcc from NanoStringQCPro)
# ####         numSD - number of standard deviations to calibrate the LOD
# #### OUTPUT: flag for limit of detection
# 
# limitOfDetectionQC <- function(rcc,numSD = 0){
#
#     counts = rcc$Code_Summary
#     posE = as.numeric(counts$Count[counts$Name == 'POS_E'])
#     negControls = as.numeric(counts$Count[grepl('NEG',counts$Name)])
#     if(!(posE > mean(negControls) + numSD*sd(negControls))) {return('Flag')}
#     if (posE > mean(negControls) + numSD*sd(negControls)) {return('No flag')}
# 
# }
##### HERE IS THE RUV CALCULATION AS IMPLEMENTED IN NANONORMITER()
# RUV_total <- function(raw,pData,fData,k,hkgenes = NULL,exclude = NULL){
# 
#     library(RUVSeq)
#     library(DESeq2)
#     library(limma)
#     library(matrixStats)
# 
#     if (!is.null(hkgenes)){
# 
#         fData(set)$Class[rownames(set) %in% hkgenes] = 'Housekeeping'
# 
#     }
# 
#     fData = fData[rownames(raw),]
#     int = intersect(rownames(raw),rownames(fData))
#     fData = fData[int,]
#     raw = raw[int,]
# 
#     set <- newSeqExpressionSet(as.matrix(round(raw)),
#                                phenoData=pData,
#                                featureData=fData)
# 
#     cIdx <- rownames(set)[fData(set)$Class == "Housekeeping"]
#     cIdx = cIdx[!(cIdx %in% exclude)]
#     x <- as.factor(pData$Group)
#     set <- betweenLaneNormalization(set, which="upper")
#     set <- RUVg(set, cIdx, k=k)
#     dds <- DESeqDataSetFromMatrix(counts(set),colData=pData(set),design=~1)
#     rowData(dds) <- fData
#     dds <- estimateSizeFactors(dds)
#     dds <- estimateDispersionsGeneEst(dds)
#     cts <- counts(dds, normalized=TRUE)
#     disp <- pmax((rowVars(cts) - rowMeans(cts)),0)/rowMeans(cts)^2
#     mcols(dds)$dispGeneEst <- disp
#     dds <- estimateDispersionsFit(dds, fitType="mean")
#     vsd <- varianceStabilizingTransformation(dds, blind=FALSE)
#     mat <- assay(vsd)
#     covars <- as.matrix(colData(dds)[,grep("W",colnames(colData(dds))),drop=FALSE])
#     mat <- removeBatchEffect(mat, covariates=covars)
#     assay(vsd) <- mat
#     return(list(set = set,vsd = vsd))
# 
# }

```

# Exploratory Data Analysis 

## Import metadata

```{r, import_meta, class.source = 'fold-show'}

meta_df_full <- readxl::read_xlsx('cleaned_metadata.xlsx', sheet = 'Sheet1', col_names = TRUE, col_types = "guess")
meta_df <- meta_df_full %>% dplyr::select(c(`file name`, batch, `study ID`, Age, Race, `prepregnancy BMI`, `current  BMI`, `Breast milk colllection date post delivary`, `Delivery type`))

colnames(meta_df) <- c("filename","batch","SampleID","age","race","prepreg_BMI","curr_BMI","milk_col_dt", "delivery")
meta_df$batch[28:40] <- "4"  #fix the singleton batch 

```

Let's do some exploratory analysis on the metadata before starting on the Nanostring analysis. We're looking for correlated variables or correlations between batches and variables. 

## Exploratory Plots 

### Correlation between pre-preg BMI and delivery? 
```{r, meta_EDA}
library(ggpubr)
# Box plots with jittered points
# :::::::::::::::::::::::::::::::::::::::::::::::::::
# Change outline colors by groups: dose
# Use custom color palette
# Add jitter points and change the shape by groups
 p <- ggboxplot(meta_df, x = "delivery", y = "prepreg_BMI",
                color = "delivery", palette =c("#00AFBB", "#E7B800","#FC4E07"),
                add = "jitter")
 
 my_comps <- list( c("vaginal", "vbac"), c("vaginal","c-sec"), c("vbac","c-sec"))
 p <- p + stat_compare_means(comparisons = my_comps) + stat_compare_means(label.y=50)
 p

```
 
### Correlation between batch and mean BMI

Sample batch appears to be at possibly partially confounded with mean BMI in both pre- and post-pregnancy BMI. We may want to try excluding batches 6 and 7 to see if discovered DE miRNAs are robust to the presence of these batches with higher mean BMI.  

However, when we look at % overweight after classifying according to BMI > 24.25, batches 6-8 aren't too far from the others.  Batch 9 has only lean samples.  

```{r, meta_EDA2}
p1 <- ggboxplot(meta_df, x = "batch", y = "prepreg_BMI",
                color = "batch",
                add = "jitter")
 
p1 


p2 <- ggboxplot(meta_df, x = "batch", y = "curr_BMI",
                color = "batch",
                add = "jitter")
 
p2

meta_df <- meta_df %>% dplyr::mutate(
  status_ov = dplyr::case_when(
    .data$prepreg_BMI < 24.25 ~ "Lean",
    .data$prepreg_BMI >=24.25 ~ "Over_Obese",
    TRUE ~ NA_character_
    )
) %>% dplyr::mutate(
  status_ob = dplyr::case_when(
    .data$prepreg_BMI < 24.25 ~ "Lean",
    .data$prepreg_BMI > 30 ~ "Obese",
    (.data$prepreg_BMI >= 24.25 & .data$prepreg_BMI <= 30) ~ "Overweight"
    )
)  

p3 <- ggplot(meta_df, aes(y=batch, fill=status_ov)) + geom_bar(position="fill") + ggtitle("Fraction Overweight by Batch; BMI > 24.25")
p3

p4 <- ggplot(meta_df, aes(y=batch, fill=status_ob)) + geom_bar(position="fill") + ggtitle("Fraction Obese by Batch; BMI > 30")

p4

```

### Correlations between dataset variables 

Only pre- and current BMI appear to be correlated in a significant way.  

```{r, corr, class.source = 'fold-show'}


df <- meta_df %>% dplyr::select(c(batch,age,prepreg_BMI,curr_BMI,milk_col_dt)) %>% mutate_at(vars(batch),factor) %>% as.data.frame()
groups <- df[,1]
pairs(df[,2:5],                     # Data frame of variables
      labels = colnames(df[,2:5]),  # Variable names
      pch = 21,                 # Pch symbol
      bg = rainbow(9)[groups],  # Background color of the symbol (pch 21 to 25)
      col = rainbow(9)[groups], # Border color of the symbol
      main = "Breastmilk dataset (batch=color)",    # Title of the plot
      row1attop = TRUE,         # If FALSE, changes the direction of the diagonal
      gap = 1,                  # Distance between subplots
      cex.labels = NULL,        # Size of the diagonal text
      font.labels = 1,
      lower.panel = panel.smooth,
      upper.panel = panel.cor)          # Font style of the diagonal text
```

## Variable distributions 

Here, we look at the distribution of age and BMI in the dataset.  
```{r, dist}
 # Density plot with mean lines and marginal rug
# :::::::::::::::::::::::::::::::::::::::::::::::::::
# Change outline and fill colors by groups ("sex")
# Use custom palette
p <- gghistogram(meta_df, x = "age",
   add = "mean", rug = TRUE, color = "blue")
p

p <- ggdensity(meta_df, x = "prepreg_BMI",
   add = "mean", rug = TRUE, color = "blue")
p

p <- ggdensity(meta_df, x = "curr_BMI",
   add = "mean", rug = TRUE, color = "blue")
p
```


# RUV-seq QC and Normalization 

RUV-seq method of Love et. al. for best-practices normalization and removal of unwanted technical artifacts

Here, we will follow the method of Love, et. al. (https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8138885/):  

**"Using DESeq2 [25], we identified genes differentially expressed in NK cells primed by CTV-1 or IL-2 cytokines compared to unprimed NK cells at FDR-adjusted equation M22. The two normalization methods led to a different number of differentially expressed genes with a limited overlap of significant genes by both methods (Figure 4A). The raw equation M23-value histograms from differential expression analysis using nSolver-normalized expression exhibited a slope toward 0 for equation M24-values under 0.3, which can indicate issues with unaccounted-for correlations among samples [42], such as residual technical variation. The distributions of equation M25-values using the RUVSeq-normalized data were closer to uniform throughout the range [0,1] for most genes (Figure 4B). While the log2-fold changes were correlated between the two normalization procedures, the genes found to be differentially expressed only with nSolver-normalized data tended to have large standard errors with RUVSeq-normalized data and therefore not statistically significant using RUVSeq (Figure 4C). These differences in DE results emphasize the importance of properly validating normalization prior to downstream genomic analyses."**

## Import data 

### Create pheno and expr tables
```{r, import_data, class.source = 'fold-show'}
#getwd()
files.RCC = list.files(".", full.names = TRUE)
files.RCC = files.RCC[grepl('RCC',files.RCC)]

head(files.RCC)

ng = nrow(readRcc(files.RCC[1])$Code_Summary)
ncol = length(files.RCC)

raw_expression = as.data.frame(matrix(nrow = ng,ncol = length(files.RCC)+2))
colnames(raw_expression)[1:2] = c('Gene','Class')
pData = as.data.frame(matrix(nrow = length(files.RCC),ncol = 11))
colnames(pData) = c('BCAC_ID','SampleID','Owner','Comments','Date','GeneRLF','SystemAPF','imagingQC',
                    'bindingDensityQC','limitOfDetectionQC','positiveLinearityQC')
raw_expression[,1:2] = readRcc(files.RCC[1])$Code_Summary[,c(2,1)]

head(pData, 5)
head(raw_expression, 5)
```

### Populate empty tables from RCC

```{r, create_pData, message=FALSE,warning=FALSE}

## NOTE: I have to override the positiveLinQC function for this panel b/c it uses two types of positive controls and that confuses the grepl search.  

positiveLinQC <- function(rcc){

     counts = rcc$Code_Summary
     #posControls = as.numeric(counts$Count[grepl('POS_',counts$Name)])
     posControls = as.numeric(counts$Count[grepl('^POS_',counts$Name)])
     known = c(128,128/4,128/16,128/64,128/256,128/(256*4))
     r2 = summary(lm(sort(posControls)~sort(known)))$r.squared
     if(!(r2 > .95) | is.na(r2)) {return('Flag')}
     if(r2 > .95) {return('No flag')}
 
}

## Override this function to account for two types of Neg controls.  
limitOfDetectionQC <- function(rcc,numSD = 0){
  counts = rcc$Code_Summary
  posE = as.numeric(counts$Count[counts$Name == 'POS_E'])
  negControls = as.numeric(counts$Count[grepl('^NEG',counts$Name)])
  if(!(posE > mean(negControls) + numSD*sd(negControls))) {return('Flag')}
  if (posE > mean(negControls) + numSD*sd(negControls)) {return('No flag')}
  }

## 
## Populate pData and raw expr tables from RCC files
for (i in 1:length(files.RCC)){
  #i = 1 
  print(i)
  rcc = readRcc(files.RCC[i])
  raw = rcc$Code_Summary
  
  raw_expression[,i+2] = as.numeric(raw$Count)
  #colnames(raw_expression)[i+2] = strsplit(files.RCC[i],'_')[[1]][2:4]
  pData[i,2:7] = as.vector(rcc$Sample_Attributes)
  pData$imagingQC[i] = imagingQC(rcc)
  pData$bindingDensityQC[i] = bindingDensityQC(rcc,.05,2.25)
  pData$limitOfDetectionQC[i] = limitOfDetectionQC(rcc)
  pData$positiveLinearityQC[i] = positiveLinQC(rcc)
}

## Munge pData and metadata together; create treatment classes
pData$SampleID <- meta_df$SampleID
pData <- dplyr::left_join(pData, meta_df, by = "SampleID")
rownames(pData) <- pData$SampleID 

colnames(raw_expression)[3:82] <- pData$SampleID

head(pData)
```

## Quality Control Analysis

No QC flags are set on any of the 80 samples: 
```{r, checkQCflags}
pData[,7:10]
```

This hidden code block does more setup and preparation for analysis.  
```{r, make_pData, warning=FALSE}
raw = raw_expression[,-c(1:2)]
fData = raw_expression[,c(1:2)]
rownames(raw) = fData$Gene
cIdx <- fData$Gene[fData$Class == "Housekeeping"]
pData$HK_Gene_Miss = colSums(raw[cIdx,] == 0)
rownames(fData) = fData$Gene
rownames(raw) = fData$Gene
#rownames(pData) = colnames(raw)

#
```

### Check Housekeeping Genes

So let's proceed to checking whether housekeeping genes correlate with treatment.  RUV-seq normalization assumes that housekeeping genes DO NOT correlate with treatment or biology of interest.  
```{r,housekeeping}
#### CHECK IF housekeeping Genes ARE ASSOCIATED WITH PRIMARY PHENO
hk_raw = raw[cIdx,]
pval = vector(length = nrow(hk_raw))

require(MASS)

for (i in 1:nrow(hk_raw)){
  
  reg = glm.nb(as.numeric(hk_raw[i,]) ~ as.factor(pData$status_ov))
  pval[i] = coef(summary(reg))[2,4]
  
}

```

### P-values

These are the p-values of the relationship between the housekeeping genes and the treatment groups.  There appears to be no correlation between the housekeeping miRNAs and the obese/lean status (this is good!)

```{r, pval_hk}
pval <- pval %>% as_tibble() %>% mutate(hkgene = rownames(hk_raw))
pval 

```
### Check limit of detection 
We want to define how many genes are below the limit of detection (i.e., >1SD below the negative control mean).  

```{r, blod}
neg_raw <- raw %>% filter(row.names(raw) %in% c("NEG_A","NEG_B","NEG_C","NEG_D","NEG_E","NEG_F","NEG_G","NEG_H"))
lod <- colMeans(neg_raw) - apply(neg_raw,1,sd)
num_endo_blod <- colSums(raw_expression[raw_expression$Class == "Endogenous1", -c(1:2)] < lod)
num_hk_blod <- colSums(raw_expression[raw_expression$Class == "Housekeeping", -c(1:2)] < lod)

## Check the BLOD numbers by batch 
df <- data.frame(below_lim = num_endo_blod, batch = pData$batch, name=pData$SampleID)
p <- ggbarplot(df, y="below_lim", x="name", color="batch", fill="batch")
p <- p + ggtitle("Number Endogenous miRNAs Below Limit of Detection by Batch")
p
```

We can clearly see a batch effect with Batch 4 having larger than normal "Below Limit of Detection" miRNAs.  

## Apply RUVg normalization 

Now, we remove correlated negative control genes and apply RUVg normalization: 
```{r,RUV_normalization, results='hide', message=FALSE}

## k = 1,2, and 3 
## k is the number of sources of technical confounding (i.e., suspected batches)
norm.dat.k1 <- NanoNormIter::RUV_total(raw,pData,fData,k = 1)
norm.dat.k2 <- NanoNormIter::RUV_total(raw,pData,fData,k = 2)
norm.dat.k3 <- NanoNormIter::RUV_total(raw,pData,fData,k = 3)
                               
```

### RLE analysis {.tabset}

Here, we visualize the raw and RUV normalized (k=1,2, or 3; k is the number of sources of suspected technical confounding) datasets using an RLE plot.  An RLE plot shows the boxplots of the log-ratios of the gene-level read counts of each sample to those of a reference sample (defined as the median across the samples). Ideally, the distributions should be centered around the zero line and as tight as possible. Clear deviations indicate the need for normalization and/or the presence of outlying samples.

#### Raw Data 

These are the raw, non-normalized counts.  Y-axis is the median deviation of log expression.  We can see systematic deviations from the median line (zero).  This is bad and indicates a definite batch effect.  
```{r, vis_raw_RLE}

## Raw data
EDASeq::plotRLE(as.matrix(raw), cex.lab=0.5)

```

#### RUVg (k=1)

These are RUVSeq normalized with K=1. The batch effect in samples ~30-40 has been removed.  
```{r, vis_RUV_RLE_1}
## K=1
EDASeq::plotRLE(norm.dat.k1$set)

```

#### RUVg (k=2)

These are RUVSeq normalized with k=2. 
```{r, vis_RUV_RLE_2}
## K=2
EDASeq::plotRLE(norm.dat.k2$set)
```

#### RUVg (k=3)

These are RUVSeq normalized with k=3. 
```{r, vis_RUV_RLE_3}
## K=3
EDASeq::plotRLE(norm.dat.k3$set)
```
### {-}

### PCA analysis {.tabset}

Here were look at the PCA plots for the raw (non-normalized), and RUVg normalized data with k=1,2,or3

### PCA raw 

Here, there is a huge batch effect.  
```{r, pca_plots}
## Raw data
# making variance stabilized raw counts for later PCA plotting 
dds_raw_counts <- DESeqDataSetFromMatrix(as.matrix(raw),colData=pData,design=~status_ov)
vst_raw_counts <- DESeq2::varianceStabilizingTransformation(dds_raw_counts)
pcaExplorer::pcaplot(vst_raw_counts, intgroup = "batch", ellipse = FALSE, text_labels = FALSE)
pcaExplorer::pcaplot(vst_raw_counts, intgroup = "status_ov", ellipse = FALSE, text_labels = FALSE)
pcaExplorer::pcaplot(vst_raw_counts, intgroup = "status_ob", ellipse = FALSE, text_labels = FALSE)




```


### PCA RUV (k=1)

Removing one batch variable with RUVg lessens the batch effect somewhat.
```{r, pca2}
## RUVg norm, k=1
pcaExplorer::pcaplot(norm.dat.k1$vsd, intgroup = "batch", ellipse = FALSE, text_labels = FALSE)
pcaExplorer::pcaplot(norm.dat.k1$vsd, intgroup = "status_ov", ellipse = FALSE, text_labels = FALSE)
pcaExplorer::pcaplot(norm.dat.k1$vsd, intgroup = "status_ob", ellipse = FALSE, text_labels = FALSE)
```

### PCA RUV (k=2)

Removing two batch effects (variables) creates a more reasonable looking PCA plot.  Unfortunately, obese and non-obese do not cluster (this doesn't mean that we won't find some DE miRNAs)  
```{r,pca3}
## RUVg norm, k=2
pcaExplorer::pcaplot(norm.dat.k2$vsd, intgroup = "batch", ellipse = FALSE, text_labels = FALSE)
pcaExplorer::pcaplot(norm.dat.k2$vsd, intgroup = "status_ov", ellipse = FALSE, text_labels = FALSE)
pcaExplorer::pcaplot(norm.dat.k2$vsd, intgroup = "status_ob", ellipse = FALSE, text_labels = FALSE)
```


### PCA RUV (k=3)

Removing 3 batch variables may be overkill.  We want to be careful not to overfit the data or remove biological effects.  
```{r,pca4}
## RUVg norm, k=3
pcaExplorer::pcaplot(norm.dat.k3$vsd, intgroup = "batch", ellipse = FALSE, text_labels = FALSE)
pcaExplorer::pcaplot(norm.dat.k3$vsd, intgroup = "status_ov", ellipse = FALSE, text_labels = FALSE)
```

### {-}

# DESeq2 DE analysis 

## Create DESEQ2 object 
Let's test the DE analysis on these data using RUV normalized data (k=2)
 
```{r, DESeq2, class.source = 'fold-show'}
dds <- DESeqDataSetFromMatrix(countData = counts(norm.dat.k2$set[26:828,]),
                              colData = pData(norm.dat.k2$set),
                              design = ~ W_1 + W_2 + status_ov)  #since we largely normalized out our technical batches, we will not include it explicitly in the design formula
dds <- DESeq(dds)

```


## Analyze DE changes

### Overweight vs Lean 
```{r, res1}
res_OV <- as.data.frame(results(dds,contrast = c('status_ov','Over_Obese','Lean')))
```


### DEG table 
```{r, table1}
## Table of top DE genes 
res_OV_sig <- res_OV %>% 
  arrange(padj) %>% 
  filter(padj < 0.1) %>% 
  dplyr::select(c(padj, baseMean, log2FoldChange)) %>% 
  mutate(across(c(1:3), ~round(.x, digits=3)))
  
  
res_OV_sig
```




```{r, counts1, class.source = 'fold-show'}
## Count plots of individual top DE genes 
plotCounts(dds, "hsa-miR-642a-3p|0", intgroup = "status_ov")
plotCounts(dds, "hsa-miR-630|0", intgroup = "status_ov")
plotCounts(dds, "hsa-miR-575|0", intgroup = "status_ov")
plotCounts(dds, "hsa-miR-223-3p|0", intgroup = "status_ov")

```

```{r, volPlot}
df <- res_OV %>% mutate(gene_name = rownames(.)) %>% filter(padj < 0.1) 
p <- do_vol_plot(df = df, sig = 0.05, fc = 0.3, size = 4)
p <- p + ggtitle("Overweight vs Lean Volcano plot")
p
```

## Create DESEQ2 object 
Let's test again looking at just obese vs lean: 
 
```{r, DESeq2_OB, class.source = 'fold-show'}

dat <- norm.dat.k2$set
dat_ob <- dat[,dat$status_ob %in% c("Lean","Obese")]
dds_ob <- DESeqDataSetFromMatrix(countData = counts(dat_ob[26:828,]),
                              colData = pData(dat_ob),
                              design = ~ W_1 + W_2 + status_ob)  #since we largely normalized out our technical batches, we will not include it explicitly in the design formula
dds_ob <- DESeq(dds_ob)

```

## Analyze DE changes

### Obese vs Lean 
```{r, res2}
res_OB <- as.data.frame(results(dds_ob,contrast = c('status_ob','Obese','Lean')))
```


### DEG table 
```{r, table2}
## Table of top DE genes 
res_OB_sig <- res_OB %>% 
  arrange(padj) %>% 
  filter(padj < 0.1) %>% 
  dplyr::select(c(padj, baseMean, log2FoldChange)) %>% 
  mutate(across(c(1:3), ~round(.x, digits=3))) 

res_OB_sig


```

```{r, countplots}
df <- plotCounts(dds_ob, gene = "hsa-miR-30c-5p|0", intgroup = "status_ob", returnData = TRUE)
ggboxplot(df, x = "status_ob", y="count", fill = "status_ob") + ggtitle("Counts of hsa-miR-30c-5p|0 in Lean vs Obese samples")
```

```{r, volPlot2}
df <- res_OB %>% mutate(gene_name = rownames(.)) %>% filter(padj < 0.1) 
p <- do_vol_plot(df = df, sig = 0.05, fc = 0.3, size = 4)
p <- p + ggtitle("Obese vs Lean Volcano plot")
p
```

### Venn overlap of overweight vs obese miRNAs

Here we are comparing miRNAs found as DE between overweight (+obese) vs lean, and just obese (excluding overweight) vs lean. 

The "obese" set contains all but 2 miRNAs found in the "overweight" set and also contains 22 other miRNAs.  

```{r, VENN}
library(Vennerable)
v <- Vennerable::Venn(list(obese = rownames(res_OB_sig), overweight = rownames(res_OV_sig)))
plot(v, doWeights = TRUE)
```

# Conclusions


# Computational Environment 

```{r, sesh}
sessionInfo()
```

