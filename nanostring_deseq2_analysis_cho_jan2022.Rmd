---
title: "NanoString NCounter analysis: Breastmilk miRNA Obese vs Normals"
author: "Michael S Chimenti"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    df_print: paged
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: true
    code_folding: hide
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Introduction

## Project Summary 

**Our central hypothesis is that altered breast milk EV (bEV)-miRNA profiles in obese mothers affect the gene expression of intestinal epithelial cells (IECs), which might be associated with unfavorable health outcomes in children. Our long-term goal is to promote the health and development of children by improving the quality of breast milk through interventions and therapeutic strategies. The objectives of this study to achieve the long-term goal are 1) to understand the physiological roles of bEVs associated with maternal obesity, and 2) to establish a research team investigating bEVs with collaborators for the further studies. To attain the overall objectives, we propose the following specific aims:

Aim1. To determine differentially expressed bEV-miRNAs in obese mothers; We will recruit normal weight mothers and overweight/obese mothers and who have delivered a baby in the past one month. EV-miRNA expression profile will be analyzed with Nanostring Human miRNA Expression Panel. It will allow us to screen 798 biologically relevant miRNAs, which will enable us to find novel biomarkers related to maternal obesity. Our working hypothesis is that immune-response and metabolism-related miRNAs are altered in overweight/obese mother breast milk.
**

## Methods 

Nanostring NCounter data were obtained as “RCC” format files. These were imported into R with 'readRcc' function from the NanoStringQCPro package (Bioconductor; https://www.bioconductor.org/packages/release/bioc/html/NanoStringQCPro.html; Bourgon et. al.).  Here, we follow the NanoString RUV normalization procedure outlined in Love, et. al (ref), for quality control checks and iterative RUVg normalization (Risso, et. al.).  All samples passed QC checks and were included in the analysis.  After visualization of the normalized data with RLE and PCA plots, RUVg-normalized data (k=2) was chosen for downstream DEG analysis.  A DESeq2 'dds' object was created from the normalized data using ‘DESeqDataSetFromMatrix’ with design conditioned on a grouped factor (genotype and FPI).  Pathway and GO term enrichment was carried out using ‘ClusterProfiler’ (ref).  R code for the analysis is available on Github.    

Nickles D, Sandmann T, Ziman R, Bourgon R (2021). NanoStringQCPro: Quality metrics and data processing methods for NanoString mRNA gene expression data. R package version 1.26.0.

Bhattacharya A, Hamilton AM, Furberg H, et al. An approach for normalization and quality control for NanoString RNA expression data. Brief Bioinform. 2021;22(3):bbaa163. doi:10.1093/bib/bbaa163

Risso D, Ngai J, Speed T, Dudoit S (2014). “Normalization of RNA-seq data using factor analysis of control genes or samples.” Nature Biotechnology, 32(9), 896–902. In press, http://www.nature.com/nbt/journal/v32/n9/full/nbt.2931.html.

Love MI, Huber W, Anders S (2014). “Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2.” Genome Biology, 15, 550. doi: 10.1186/s13059-014-0550-8.

#### Library imports 
Click the "Code" button to see hidden code.  
```{r, imports, warning=FALSE, message=FALSE}

## Format and plotting 
library(ggrepel)
library(kableExtra)
library(pcaExplorer)
library(Vennerable)
require(ggplot2)

## Nanostring specific 
library(RUVSeq)
library(NanoStringQCPro)
library(NanoNormIter)


## DE analysis 
library(DESeq2)
library(limma)
library(matrixStats)
library(EnvStats)

## TidyR
library(tidyverse)
library(magrittr)

```

#### Function definitions 

```{r, function_defs}
## Volcano Plot

do_vol_plot <- function(df, sig=0.05, fc=0.5, size = 4){
  
  df_sig<- df %>% filter(padj < sig)
  
  ## genes with labels -- signficant,decreased expression and start with IGF
  
  df_label<- df %>% 
              filter(padj < sig, abs(log2FoldChange) > fc)
              #mutate(short_id = stringr::str_split(gene_id, "000000") %>% map_chr(.,2))
  
  
  ## plot
  
  p <- ggplot(df, aes(log2FoldChange, -log10(padj)))  +
      geom_point(size=0.8, color="black", alpha=.8) + 
      geom_point(size=0.8, data=df_sig, aes(log2FoldChange, -log10(padj)), colour="red") +
       geom_text_repel(size= size, 
                    colour="black",
                    segment.size=0.1, 
                    nudge_x=0.06, 
                    nudge_y=0.06, 
                    data=df_label,
                    aes(log2FoldChange, -log10(padj), label=gene_name), 
                    max.iter= 200, 
                    point.padding = 0.15, 
                    segment.alpha = 1, 
                    box.padding=.15,
                    min.segment.length = unit(0.15, 'lines'),size=2.5) +
    theme(
      axis.text.x = element_text(size=12),
      axis.text.y = element_text(size=12),
      axis.title.x = element_text(size=14, margin = margin(t = 10, r = 0, b = 10, l = 0)),
      axis.title.y = element_text(size=14, margin = margin(t = 0, r = 10, b = 0, l = 10)),
      plot.margin =unit(c(.5,.5,.5,.5),"cm"),
      plot.title = element_text(size = 11)
    )
  
  return (p)
}


#### THESE FUNCTIONS ARE IMPORTED BY 'NANONORMITER' PACKAGE
# FOR REFERENCE, HERE ARE THE QC CHECKS: 
# imagingQC <- function(rcc){
# 
#     fovRatio = as.numeric(rcc$Lane_Attributes[3]) / as.numeric(rcc$Lane_Attributes[2])
#     if (!(fovRatio > .75)) {return('Flag')}
#     if (fovRatio > .75) {return('No flag')}
# 
# }
# 
# #### INPUT: rcc - input from rcc (use readRcc from NanoStringQCPro)
# ####         low, high - the lower and upper limits for binding density
# #### OUTPUT: flag for binding density
# 
# bindingDensityQC <- function(rcc,low,high){
# 
#     bd = as.numeric(rcc$Lane_Attributes[6])
#     if(!(bd < high & bd > low)) {return('Flag')}
#     if (bd < high & bd > low) {return('No flag')}
# 
# 
# }
# 
# #### INPUT: rcc - input from rcc (use readRcc from NanoStringQCPro)
# #### OUTPUT: flag for linearity for positive controls
# 
# positiveLinQC <- function(rcc){
# 
#     counts = rcc$Code_Summary
#     posControls = as.numeric(counts$Count[grepl('POS_',counts$Name)])
#     known = c(128,128/4,128/16,128/64,128/256,128/(256*4))
#     r2 = summary(lm(sort(posControls)~sort(known)))$r.squared
#     if(!(r2 > .95) | is.na(r2)) {return('Flag')}
#     if(r2 > .95) {return('No flag')}
# 
# }
# 
# #### INPUT: rcc - input from rcc (use readRcc from NanoStringQCPro)
# ####         numSD - number of standard deviations to calibrate the LOD
# #### OUTPUT: flag for limit of detection
# 
# limitOfDetectionQC <- function(rcc,numSD = 0){
#
#     counts = rcc$Code_Summary
#     posE = as.numeric(counts$Count[counts$Name == 'POS_E'])
#     negControls = as.numeric(counts$Count[grepl('NEG',counts$Name)])
#     if(!(posE > mean(negControls) + numSD*sd(negControls))) {return('Flag')}
#     if (posE > mean(negControls) + numSD*sd(negControls)) {return('No flag')}
# 
# }
##### HERE IS THE RUV CALCULATION AS IMPLEMENTED IN NANONORMITER()
# RUV_total <- function(raw,pData,fData,k,hkgenes = NULL,exclude = NULL){
# 
#     library(RUVSeq)
#     library(DESeq2)
#     library(limma)
#     library(matrixStats)
# 
#     if (!is.null(hkgenes)){
# 
#         fData(set)$Class[rownames(set) %in% hkgenes] = 'Housekeeping'
# 
#     }
# 
#     fData = fData[rownames(raw),]
#     int = intersect(rownames(raw),rownames(fData))
#     fData = fData[int,]
#     raw = raw[int,]
# 
#     set <- newSeqExpressionSet(as.matrix(round(raw)),
#                                phenoData=pData,
#                                featureData=fData)
# 
#     cIdx <- rownames(set)[fData(set)$Class == "Housekeeping"]
#     cIdx = cIdx[!(cIdx %in% exclude)]
#     x <- as.factor(pData$Group)
#     set <- betweenLaneNormalization(set, which="upper")
#     set <- RUVg(set, cIdx, k=k)
#     dds <- DESeqDataSetFromMatrix(counts(set),colData=pData(set),design=~1)
#     rowData(dds) <- fData
#     dds <- estimateSizeFactors(dds)
#     dds <- estimateDispersionsGeneEst(dds)
#     cts <- counts(dds, normalized=TRUE)
#     disp <- pmax((rowVars(cts) - rowMeans(cts)),0)/rowMeans(cts)^2
#     mcols(dds)$dispGeneEst <- disp
#     dds <- estimateDispersionsFit(dds, fitType="mean")
#     vsd <- varianceStabilizingTransformation(dds, blind=FALSE)
#     mat <- assay(vsd)
#     covars <- as.matrix(colData(dds)[,grep("W",colnames(colData(dds))),drop=FALSE])
#     mat <- removeBatchEffect(mat, covariates=covars)
#     assay(vsd) <- mat
#     return(list(set = set,vsd = vsd))
# 
# }

```

# RUVSeq Analysis 

RUV-seq method of Love et. al. for best-practices normalization and removal of unwanted technical artifacts

Here, we will follow the method of Love, et. al. (https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8138885/):  

**"Using DESeq2 [25], we identified genes differentially expressed in NK cells primed by CTV-1 or IL-2 cytokines compared to unprimed NK cells at FDR-adjusted equation M22. The two normalization methods led to a different number of differentially expressed genes with a limited overlap of significant genes by both methods (Figure 4A). The raw equation M23-value histograms from differential expression analysis using nSolver-normalized expression exhibited a slope toward 0 for equation M24-values under 0.3, which can indicate issues with unaccounted-for correlations among samples [42], such as residual technical variation. The distributions of equation M25-values using the RUVSeq-normalized data were closer to uniform throughout the range [0,1] for most genes (Figure 4B). While the log2-fold changes were correlated between the two normalization procedures, the genes found to be differentially expressed only with nSolver-normalized data tended to have large standard errors with RUVSeq-normalized data and therefore not statistically significant using RUVSeq (Figure 4C). These differences in DE results emphasize the importance of properly validating normalization prior to downstream genomic analyses."**


## Import metadata

```{r, import_meta}

meta_df_full <- readxl::read_xlsx('cleaned_metadata.xlsx', sheet = 'Sheet1', col_names = TRUE, col_types = "guess")
meta_df <- meta_df_full %>% dplyr::select(c(`file name`, batch, `study ID`, Age, Race, `prepregnancy BMI`, `current  BMI`, `Breast milk colllection date post delivary`, `Delivery type`))

colnames(meta_df) <- c("filename","batch","sampleID","age","race","prepreg_BMI","curr_BMI","milk_col_dt", "delivery")
meta_df$batch[28:40] <- "4"  #fix the singleton batch 

```

Let's do some exploratory analysis on the metadata before starting on the Nanostring analysis. We're looking for correlated variables or correlations between batches and variables. 

### Exploratory Analysis {.tabset}

## Correlation between pre-preg BMI and delivery? 
```{r, meta_EDA}
library(ggpubr)
# Box plots with jittered points
# :::::::::::::::::::::::::::::::::::::::::::::::::::
# Change outline colors by groups: dose
# Use custom color palette
# Add jitter points and change the shape by groups
 p <- ggboxplot(meta_df, x = "delivery", y = "prepreg_BMI",
                color = "delivery", palette =c("#00AFBB", "#E7B800","#FC4E07"),
                add = "jitter")
 
 my_comps <- list( c("vaginal", "vbac"), c("vaginal","c-sec"), c("vbac","c-sec"))
 p <- p + stat_compare_means(comparisons = my_comps) + stat_compare_means(label.y=50)
 p

```
 
## Correlation between batch and BMI?

Sample batch appears to be at least partially confounded with mean BMI in both pre- and post-pregnancy BMI.  

```{r, meta_EDA2}
p1 <- ggboxplot(meta_df, x = "batch", y = "prepreg_BMI",
                color = "batch",
                add = "jitter")
 
p1 


p2 <- ggboxplot(meta_df, x = "batch", y = "curr_BMI",
                color = "batch",
                add = "jitter")
 
p2

df <- meta_df %>% select(c(batch,age,prepreg_BMI,curr_BMI,milk_col_dt)) %>% mutate_at(vars(batch),factor) %>% as.data.frame()
groups <- df[,1]
pairs(df[,2:5],                     # Data frame of variables
      labels = colnames(df[,2:5]),  # Variable names
      pch = 21,                 # Pch symbol
      bg = rainbow(9)[groups],  # Background color of the symbol (pch 21 to 25)
      col = rainbow(9)[groups], # Border color of the symbol
      main = "BM dataset",    # Title of the plot
      row1attop = TRUE,         # If FALSE, changes the direction of the diagonal
      gap = 1,                  # Distance between subplots
      cex.labels = NULL,        # Size of the diagonal text
      font.labels = 1)          # Font style of the diagonal text
```



```{r}
 # Density plot with mean lines and marginal rug
# :::::::::::::::::::::::::::::::::::::::::::::::::::
# Change outline and fill colors by groups ("sex")
# Use custom palette
p <- gghistogram(meta_df, x = "age",
   add = "mean", rug = TRUE, color = "blue")
p

p <- ggdensity(meta_df, x = "prepreg_BMI",
   add = "mean", rug = TRUE, color = "blue")
p

p <- ggdensity(meta_df, x = "curr_BMI",
   add = "mean", rug = TRUE, color = "blue")
p
```





```



## Import RCC files 

### Create pheno and expr tables
```{r, import_data}
files.RCC = list.files("./RCC", full.names = TRUE)
#files.RCC = files.RCC[grepl('RCC',files.RCC)]
ng = nrow(readRcc(files.RCC[1])$Code_Summary)
ncol = length(files.RCC)

raw_expression = as.data.frame(matrix(nrow = ng,ncol = length(files.RCC)+2))
colnames(raw_expression)[1:2] = c('Gene','Class')
pData = as.data.frame(matrix(nrow = length(files.RCC),ncol = 11))
colnames(pData) = c('BCAC_ID','SampleID','Owner','Comments','Date','GeneRLF','SystemAPF','imagingQC',
                    'bindingDensityQC','limitOfDetectionQC','positiveLinearityQC')
raw_expression[,1:2] = readRcc(files.RCC[1])$Code_Summary[,c(2,1)]

head(pData, 5)
head(raw_expression, 5)
```
